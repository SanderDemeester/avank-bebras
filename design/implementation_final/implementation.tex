\documentclass[]{article}
\usepackage[a4paper]{geometry}
\usepackage[dutch]{babel}
\usepackage{listings}

\setlength{\parindent}{0pt}
\setlength{\parskip}{14pt}

\author{
    Ruben Taelman \\
    Sander Demeester \\
    Jens Rammant \\
    Eddy Van Den Heuvel \\
    Thomas Mortier \\
    Kevin Stobbelaar \\
    Felix Van der Jeugt
}

\title{
    Implementation Plan \\
    Avank Bebras
}

\setlength{\parskip}{12pt}
\setlength{\parindent}{0pt}

\begin{document}

\maketitle

\tableofcontents
\clearpage

\begin{section}{In General}
    This project makes use of the MVC pattern. Because of this, our app folder is divided
    into three big parts which obviously are models, views and controllers. Each of these
    folders pretty much have the same substructure. For example, a model in the models
    folders will have a corresponding controller in the controllers folder on the same
    sub-folder location. However, when some models, views and/or controllers weren't
    necessary in a certain way, they just won't exist.
    
    This project is based on the Play! framework version 2.0.4. We use Java 1.7 for our
    models and controllers, and Scala for our views. JQuery and Bootstrap are also
    extensively used inside our views and separate Javascript files.
\end{section}

\begin{section}{Parts}
    \begin{subsection}{Languages}
        EMessages is an extension of the Messages class that is provided by the Play!
        framework. The provided class didn't support changing of languages for a certain
        session, so our extension allows us to do this anyway.
        
        We also use messages.[language code] files inside the conf directory to translate
        everything in our application. The application.conf file has a key application.langs
        that contains a list of languages that are supported by the application and
        for which a messages file exists. To add a language to the application you can simply
        translate the messages file and add the language code to application.langs.
    \end{subsection}
    \begin{subsection}{Main view}
        To make sure all our views look the same, we've created one main view that has three
        input arguments. A title, a list of links and an html content. The first just sets
        the page title to the given value. The second argument is a way to show breadcrumbs.
				The last arguments justs puts the given content inside the page.
        The main view itself adds all required link and script tags and also the common
        element of each web page, like the navigation on the top of the page.
    \end{subsection}
    \begin{subsection}{AuthenticationManager}
        The AuthenticationManager is the cortex of our authentication system. This is a
        singleton that keeps track of all the logged in users and their cookie.
        This class doesn't just save one user per cookie, but a stack per cookie. This
        allowed us to easily implement the mimicing of users by just pushing a user to
        the stack when a mimic happens and popping them when someone 'un-mimics' someone
        else.
        The ChainOfCommand checks which user can mimic other types of user.
    \end{subsection}
    \begin{subsection}{RBAC}
        We have different types of users with different types of roles. To easily
        assign these roles we made use of the Role Based Access Control pattern.
        This allowed us to easily create roles and assign them to types of users
        that are allowed to perform a certain action. When certain actions would require
        a certain role, the method AuthenticationManager.getInstance().getUser().hasRole(somerole)
        can be called.
    \end{subsection}
    \begin{subsection}{Questions}
        A question in the application actually consists of two parts.
        The first is the question pack file that is stored on a certain remote server
        that contains the actual question and their correct answer. This will also contain
        HTML files for both the question view and the feedback view, files that are shown
        from within those views can also be present in those packs.
        The second part is the info that is stored within the database. This is nothing
        more than the unique id of the question, an optional official id and a reference
        to the server on which the question pack is saved.
        
        The question editor allows users to create question packs that can be uploaded, 
        downloaded or submitted to the application for approval. When an organizer approves
        a question pack, they actually define the database info and send it to a remote server.
        
        The question packs are created with the help of the QuestionFactory and
        QuestionPack classes. The QuestionFactory will check the XML file that defines
        the question with an XSD file (that is included in the project). If the XML is
        valid, it will create a Question from the given file so that it can be saved in
        a QuestionPack where it can be sent to a remote server, downloaded or stored
        for approval. The QuestionIO class contains some helper methods to help the
        previous two classes for easier distribution of the questions.
    \end{subsection}
    \begin{subsection}{Competitions}
    
        Competitions have four kinds of states (as can be seen in CompetitionState).
        
        The first state is the draft state. In this state, it's only visible and editable
        by organizers. 
        
        When organizers activate the competition, it enters the active state. In this state
        teachers can see the competition and register one or more of their classes to the
        competition. When the competition is started, it is given to the singleton object
        CompetitionUserStateManager. This object will keep track of all the competitions
        and all of the CompetitionUserStates associated with each competition for when
        users enter this competition.
        
        From the moment the competition enters the running state (this will go
        automatically depending on the start date given by the organizer) the pupils
        that were registered by the teachers will be able to see the competition (if they can 
        participate in this competition) and take part of it. There they will have a predefined 
        amount of time to answer the questions.
        
        When the competition reaches the expiration date, the competition will reach the
        finished state, on which all the CompetitionUserStates that were associated to
        this competition inside the CompetitionUserStateManager will be processed and
        saved to the database so that statistics of this competition can be viewed.
        
        Competitions can in theory be executed without an internet connection since
        all the answers are saved locally via javascript. Only when the user wants to submit
        the answers, a connection to the server is required. The answers are sent to the
        server in JSON. At the server-side, the JSON will be parsed. Then the answers will
        be checked and a QuestionFeedback will be generated for that user and stored inside
        the CompetitionUserState for that user until the competition is finished.
        
    \end{subsection}
    \begin{subsection}{Password Management}
		In this day and age, a modern web application should have a good password policy and somesort of a 			security model. When the user makes an account. His password is hashed client side using a password based 			key derivation function (PBKBDF2) using a SHA1 hashing algoritme. The reason for this is that the server 			never sees the client plain text password. Because people will reuse the same password on different 		services. Then on the server side the password is hashed again using PBKDF2 with a unique per user salt. 			The server is capable to perform both operations on the server for when a teacher uploads a CVS-file. Its 			clear that it is not possible to retreive lost/forgotten passwords. This is by design. When the passwords 			are generated on the user (in the situation that a CVS is uploaded) a list can be generated containing the 			passwords. It is however imported to note that this list can not be regenerated when the process is done.
		
		A user can change his password in his account settings page. A teacher who is associated with a student 		can also reset a student passwords. Students without an email adres can also reset there password if there 			is a teacher associated with a class that they are in.
    \end{subsection} 
    \begin{subsection}{Statistics}
        TODO: Felix
    \end{subsection}
    \begin{subsection}{Mail}
        We are using email to communicate with our users. However it is not mandatory to have/use an email in our 			system. Email is used as a way to to close the communication loop between the sytem and the users 			(password reset en contact). The main difference here is that when a users wants to reset his password and he has an email associated with his account, he can reset his password on his own (not interaction with a teacher is required). If however the student does not have a email associated with account an email will be send to the teacher responsible for that student. 
    \end{subsection}
    \begin{subsection}{ClassGroups: import and export}
    	The importing of classgroups from xlsx files and the exporting of classgroups to XLSX files happens in two 				steps. 
    	The importing happens as following. The file is uploaded and given to the XLSXImporter class. The 						import function of this class reads the file and returns it as a List of Lists of Strings. Each List of 					Strings represents a row in the XLSX file, with each String in said List representing a cell of that row. The 		resulting list of list of Strings is transferred to the ClassGroupIO class. The import function of that class 		parses the List in a collection of wrappers of ClassGroup objects. These wrappers contain the imported 					ClassGroup object and all UserModel object that should be linked to that ClassGroup. They also contain a 				flag and message for each object which signify whether the imported data is valid (e.g. is there a School 				that has School id that was given in the file) and a message that gives more information on what is wrong 				with the imported data (if anything). This collection of wrappers is then returned to the Controller which 				shows it to the user in a confirmation screen. If the user saves, all valid data is saved.
    	The exporting goes in the reverse way. First the export function of the ClassGroupIO class writes the 					ClassGroup data to a List of Lists of Strings. Then the export function of XLSXImported writes that List of 				Lists of Strings to an XLSX file which is then returned to the user.
        
    \end{subsection}
    \begin{subsection}{Datadaemon}
        This singleton object always runs on the server and is able to perform
        any task at any given time or interval. This is required in the first place to automatically delete
        the uploaded images by authors in the question editor after a day and also to start and
        stop a competition at the correct start- and expiration date.
    \end{subsection}
    \begin{subsection}{Routes}
        This file is provided by the Play! framework and allows us to translate HTTP requests
        to a certain action inside a certain controller.
        This file is located inside the conf folder.
    \end{subsection}
    \begin{subsection}{DMTV}
        DMTV or Default Management Table View is used across the application to easily
        provide a clear way to make CRUD (create, read, update, delete) actions, since this
        was not provided by the Play! framework.
        To be able to use this for any model, just extend the abstract ManageableModel class.
        When you then annotate public fields with the @Editable annotation forms for this model
        can be automatically generated on runtime. To be able to access these forms, you will
        need a Manager that will actually provide you with ways to render the required
        views from your controller.
    \end{subsection}
    \begin{subsection}{DataManager}
        For small enumerations, like Grades and Difficulties, that actually don't change very
        often but are not very clean to hard code in the application, we've created a DataManager
        to be able to save these values in the database so that they can be changed by the
        administrator if needed but can easily be requested from anywhere within the application.
    \end{subsection}
    \begin{subsection}{Database}
        For a visual representation of the database tables and how they relate to each other is provided in the db-relations-visual.png file. A full specification of all the attributes and constraints of the tables is provided in the db-relations.xlsx file.
    \end{subsection}

    \begin{subsection}{Statistics}

        Because we've tried to keep the statistics as general and extensible as
        possible, they've become quite complicated. Below is first an
        explanation for the user, followed by a short guide to the code,
        including some hints on writing more statistics.

        When a users opens the statistics screen, he'll be able to select first
        the scope of his statistic. In the `Compose the desired populations`
        section, you can add populations of several kinds, and choose the colour
        they'll get in a chart.

        The kinds of populations we've provided are:
        \begin{description}
            \item[Single Populations] A single user. This will allow you to view
                data about a single user seperately. Whereas pupils can only see
                themselves, teachers can view the users in their classes as
                well. Organizers and administrators van view everyone.
            \item[Class Population] A whole class. This allows pupils to view
                anonymous data about everyone in their class. Teachers and above
                can also use this to quickly add a class.
            \item[School populations] Useful for viewing the anonymous data of
                everyone in the school. Pupils and teachers can see only their
                own schools.
            \item[All users] This provides anonymous information about the whole
                user database. Anonymous users can see this, but because of the
                size, the data specifics remain hidden.
        \end{description}

        When a user has selected his populations, he can go on selecting the
        desired statistic. These are easily selected in a dropdown list. The
        user can still finegrade the statistic by selecting filters, for
        instance adding a filter for ``Gender'' and setting it to ``Male''. Then
        only the males form the selected population will be included in the
        statistic. Note that for filters like ``Age'', you should set it to a
        range, like ``10,20'' for people between 10 and 20 years old.

        Now, as for the implementation. You can find the populations in
        \texttt{models.statistics.populations}. To write a new type of
        population, you have to implement \texttt{Population}. Register your new
        population in \texttt{PopulationType}, you can use the defined
        populations in there as an example. Finally, you have to tell the
        \texttt{PopulationChooser} which type of user gets to see which
        instances of your population. There's also a number of example avaible
        for the already existing user types and populations.

        You can also define new statistics on the selected populations. The
        current statistics and the interfaces can be found in
        \texttt{models.statistics.statistics}. The only requirements for your
        statistic are that (1) you implement \texttt{Statistic} and (2) you
        register it in \texttt{StatisticFactory}. I have however spared you a
        lot of work by writing to abstract statistics,
        \texttt{DiscreteStatistic} and \texttt{ContinuousStatistic}. These will
        create a Piechart or a Histogram if you extend them. Examples of
        discrete statistics are ``Gender'' and ``Language''. Continuous
        statistics are things like ``Age'' and ``Score''.

        As a final note, for some statistics (like the score and correct
        answers) a selected question or question set is used. These can only be
        inserted by linking people to the statistics from somewhere.

    \end{subsection}
\end{section}

\end{document}
