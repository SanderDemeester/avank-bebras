package models.question;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import models.data.Language;
import models.user.User;

import org.codehaus.jackson.JsonNode;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import play.libs.Json;

/**
 * The base class where questions for the competitions are stored in.
 * @author Ruben Taelman
 *
 */
public abstract class Question {

    /** These fields are generated on reading the XML **/
    protected String ID;
    protected Server server;
    protected QuestionType type;
    public List<Language> languages;
    protected Map<Language, String> titles;
    protected Map<Language, String> indexes;
    protected Map<Language, String> feedbacks;

    /** These fields can be altered afterwards **/
    public boolean official;
    public boolean active;
    public User author;

    /** Static fields **/
    private static final String XML_SCHEMA = "conf/questions.xsd";
    private static final Map<String, QuestionFactory> QUESTION_TYPE_NAMES = new HashMap<String, QuestionFactory>();
    static {
        QUESTION_TYPE_NAMES.put("multiple-choice-question", new MultipleChoiceQuestionFactory());
        QUESTION_TYPE_NAMES.put("regex-question", new RegexQuestionFactory());
    }

    /**
     * Don't just call this, Question need to be generated by calling the static getFromXml(String xml)
     */
    protected Question() {
        this.languages = new ArrayList<Language>();
        this.titles = new HashMap<Language, String>();
        this.indexes = new HashMap<Language, String>();
        this.feedbacks = new HashMap<Language, String>();
    }
    
    /**
     * Validate a json formatted question
     * @param json json formatted question
     * @throws QuestionBuilderException any error that can occur
     */
    public static void validateJson(String json) throws QuestionBuilderException {
        JsonNode input = Json.parse(json);
        Document doc = Question.JsonToXml(input);
        Question.getFromXml(doc);// The return is not catched because we only have to validate
    }
    
    public static File export(String json) throws QuestionBuilderException {
        JsonNode input = Json.parse(json);
        Document doc = Question.JsonToXml(input);
        Question.getFromXml(doc);// The return is not catched because we only have to validate
        try {
            // Make hash
            MessageDigest mdEnc = MessageDigest.getInstance("MD5"); 
            mdEnc.update(json.getBytes(), 0, json.length());
            String hash = new BigInteger(1, mdEnc.digest()).toString(16);
            
            String zipfile = hash+".zip";
            String xmlfile = hash+".xml";
            
            FileOutputStream fout = new FileOutputStream(zipfile);
            ZipOutputStream zout = new ZipOutputStream(fout);
            
            Source source = new DOMSource(doc);
            
            // Prepare the xml output file
            File file = new File(xmlfile);
            Result result = new StreamResult(file);
 
            // Write the DOM document to the file
            Transformer xformer = TransformerFactory.newInstance().newTransformer();
            xformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no");
            xformer.setOutputProperty(OutputKeys.METHOD, "xml");
            xformer.setOutputProperty(OutputKeys.INDENT, "yes");
            xformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            xformer.transform(source, result);
            
            // Add xml file to zip
            ZipEntry ze = new ZipEntry("question.xml");
            zout.putNextEntry(ze);
            byte[] buffer = new byte[1024];
            FileInputStream in = new FileInputStream(xmlfile);
            int len;
            while ((len = in.read(buffer)) > 0) {
                zout.write(buffer, 0, len);
            }
 
            in.close();
            
            zout.closeEntry();
            
            zout.close();
            
            return new File(zipfile);
        } catch (FileNotFoundException e) {
            throw new RuntimeException("Invalid file.", e);
        } catch (IOException e) {
            throw new RuntimeException("IO error.", e);
        } catch (TransformerConfigurationException e) {
            throw new RuntimeException("Transformation server error.", e);
        } catch (TransformerFactoryConfigurationError e) {
            throw new RuntimeException("Transformation server error.", e);
        } catch (TransformerException e) {
            throw new RuntimeException("Transformation error.", e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Internal server error.", e);
        }
    }
    
    /**
     * Creates a new question from a certain XML input
     * @param xml  absolute URL of an xml file
     * @return a new question
     * @throws QuestionBuilderException possible things that can go wrong
     */
    public static Question getFromXml(String xml) throws QuestionBuilderException {
        try {
            // Parse the given XML into a DOM tree
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
    
            // Parse our file
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(xml);
            
            return getFromXml(doc);
        } catch (ParserConfigurationException e) {
            throw new QuestionBuilderException("Incorrect XML, can't be parsed.");  
        } catch (SAXException e) {
            throw new QuestionBuilderException("The XML is invalid."+e.getMessage());
        } catch (IOException e) {
            throw new QuestionBuilderException("Can't read the xml file.");
        }
    }

    /**
     * Creates a new question from a certain XML input
     * @param xml  input stream of an xml file
     * @return a new question
     * @throws QuestionBuilderException possible things that can go wrong
     */
    public static Question getFromXml(Document doc) throws QuestionBuilderException {
        // TODO: Set Server and ID upon loading the XML file
        Question question = null;
        try {
            // create a SchemaFactory capable of understanding our schemas
            SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            // Load our schema
            Schema schema = sf.newSchema(new File(XML_SCHEMA));
            //factory.setSchema(schema); </-- DO NOT USE THIS, IT WILL ADD OPTIONAL ATTRS EVERYWHERE!

            // create a Validator instance to validate the give XML
            Validator validator = schema.newValidator();

            // Validate our document
            validator.validate(new DOMSource(doc));

            // Retrieve the root nodeList
            NodeList nodeList = doc.getChildNodes();
            nodeList = nodeList.item(0).getChildNodes();
            Node typeNode = nodeList.item(1);
            if(typeNode==null)
                typeNode = nodeList.item(0);
            String type = typeNode.getNodeName();

            // Give the nodeList to the correct QuestionFactory to make our Question
            question = QUESTION_TYPE_NAMES.get(type).newQuestion(typeNode);        
        } catch (SAXException e) {
            throw new QuestionBuilderException("The XML is invalid."+e.getMessage());
        } catch (IOException e) {
            throw new QuestionBuilderException("Can't read the XML file.");
        /*} catch (XPathExpressionException e) {
            throw new QuestionBuilderException("Can't select the root node.");*/
        } catch (NullPointerException e) {
            throw new QuestionBuilderException("Unknown question type.");
        }

        return question;
    }
    
    public static Document JsonToXml(JsonNode json) throws QuestionBuilderException {
        try {
            DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
            
            Document doc = docBuilder.newDocument();
            Element root = doc.createElementNS("bebras:Question", "root");
            
            //doc.createElement("root");
            //root.setAttributeNS("http://www.w3.org/2000/xmlns/" ,"xmlns","bebras:Question");
            
            QuestionType type = QuestionType.valueOf(json.get("type").asText());
            if(type == null)
                throw new QuestionBuilderException("Invalid question type.");
            Element questionNode = doc.createElementNS("bebras:Question", type.getXmlElement());
            
            JsonNode languages = json.get("languages");
            
            for(int i=0;i<languages.size();i++) {
                JsonNode language = languages.get(i);
                
                Element lang = doc.createElementNS("bebras:Question", "language");
                lang.setAttribute("code", language.get("language").getTextValue());
                
                Element index = doc.createElementNS("bebras:Question", "index");
                index.setTextContent(language.get("index").getTextValue());
                lang.appendChild(index);
                
                // TODO TMP
                Element feedback = doc.createElementNS("bebras:Question", "feedback");
                feedback.setTextContent(language.get("feedback").getTextValue());
                lang.appendChild(feedback);
                
                // TODO TMP
                Element title = doc.createElementNS("bebras:Question", "title");
                title.setTextContent(language.get("title").getTextValue());
                lang.appendChild(title);
                
                if(QuestionType.MULTIPLE_CHOICE.equals(type)) {
                    Element answers = doc.createElementNS("bebras:Question", "answers");
                    
                    JsonNode answerNodes = language.get("answers");
                    for(int j=0;j<answerNodes.size();j++) {
                        JsonNode answerNode = answerNodes.get(j);
                        
                        Element answer = doc.createElementNS("bebras:Question", "answer");
                        answer.setTextContent(answerNode.get("content").getTextValue());
                        if(answerNode.get("correct").asBoolean())
                            answer.setAttribute("correct", "true");
                        answers.appendChild(answer);
                    }
                    
                    lang.appendChild(answers);
                } else if(QuestionType.REGEX.equals(type)) {
                    Element input = doc.createElementNS("bebras:Question", "input");
                    input.setAttribute("regex", language.get("regex").getTextValue());
                    lang.appendChild(input);
                }
                
                questionNode.appendChild(lang);
            }
            
            root.appendChild(questionNode);
            doc.appendChild(root);
            
            return doc;
            
        } catch (ParserConfigurationException e) {
            throw new QuestionBuilderException("An unexpected internal error occured.");
        }
    }

    /**
     * Is the question official
     * @return is official
     */
    public boolean isOfficial() {
        return official;
    }

    /**
     * Sets the official value
     * @param official is this question official
     */
    public void setOfficial(boolean official) {
        this.official = official;
    }

    /**
     * Is the question active
     * @return is active
     */
    public boolean isActive() {
        return active;
    }

    /**
     * Sets the active value
     * @param active is this question active
     */
    public void setActive(boolean active) {
        this.active = active;
    }

    /**
     * Returns the server on which this question is located
     * @return the server location of this question
     */
    public Server getServer() {
        return server;
    }

    /**
     * Sets the server on which this question is located
     * @param server the server location of this question
     */
    public void setServer(Server server) {
        this.server = server;
    }

    /**
     * Get the question type
     * @return the type of the question
     */
    public QuestionType getType() {
        return type;
    }

    /**
     * Add a possible language to the question
     * @param language a language
     */
    public void addLanguage(Language language) {
        this.languages.add(language);
    }

    /**
     * Returns a list of all available languages in this question
     * @return list of languages
     */
    public List<Language> getLanguages() {
        return languages;
    }
    
    /**
     * Returns a list of all languages that are not available in this question
     * @return list of languages
     */
    public List<Language> getNonLanguages() {
        List<Language> all = new ArrayList<Language>();
        for (Language language : Language.listLanguages()) {
            if(!languages.contains(language))
                all.add(language);
        }
        return all;
    }

    /**
     * Returns the unique ID of this question on a certain server
     * @return the ID of a question
     */
    public String getID() {
        return ID;
    }

    /**
     * Returns the title in a certain Language
     * @param language chosen language
     * @return the title of this question in the given language
     */
    public String getTitle(Language language) {
        return this.titles.get(language);
    }

    /**
     * Sets the title for a given language
     * @param title the title for the question
     * @param language chosen language
     */
    public void setTitle(String title, Language language) {
        this.titles.put(language, title);
    }

    /**
     * Sets the index file name for a given language
     * @param title the index file name for the question
     * @param language chosen language
     */
    public void setIndex(String title, Language language) {
        this.indexes.put(language, title);
    }

    /**
     * Gets the index file name for a given language
     * @param language chosen language
     * @return the index file name for the question
     */
    public String getIndex(Language language) {
        return indexes.get(language);
    }

    /**
     * Sets the feedback file name for a given language
     * @param title the feedback file name for the question
     * @param language chosen language
     */
    public void setFeedback(String title, Language language) {
        this.feedbacks.put(language, title);
    }

    /**
     * Gets the feedback file name for a given language
     * @param language chosen language
     * @return the feedback file name for the question
     */
    public String getFeedback(Language language) {
        return feedbacks.get(language);
    }

}
